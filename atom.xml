<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[coding]]></title>
  <link href="http://blog.youngxiao.com/atom.xml" rel="self"/>
  <link href="http://blog.youngxiao.com/"/>
  <updated>2016-09-09T17:30:59+08:00</updated>
  <id>http://blog.youngxiao.com/</id>
  <author>
    <name><![CDATA[young]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Lockstep]]></title>
    <link href="http://blog.youngxiao.com/blog/2016/09/02/smoba-tech/"/>
    <updated>2016-09-02T15:49:25+08:00</updated>
    <id>http://blog.youngxiao.com/blog/2016/09/02/smoba-tech</id>
    <content type="html"><![CDATA[
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[大学日记]]></title>
    <link href="http://blog.youngxiao.com/blog/2016/03/15/my-five-blog/"/>
    <updated>2016-03-15T13:57:57+08:00</updated>
    <id>http://blog.youngxiao.com/blog/2016/03/15/my-five-blog</id>
    <content type="html"><![CDATA[<pre><code>曾经在读书时记录的日记，记录下，留个纪念~
</code></pre>

<!-- more -->


<h2>ACMteam成立</h2>

<pre><code>2008-03-10  

已经接触ACM快一年了，看着同年级的ACMer变得越来越强！  

自己觉得跟不上他们的脚步了（虽然自己花在上面的时间也不是很多），  

难免觉得有点失落！尤其是那个MetalHeart天天在我面前晃（不过他真的很强哈），  

把我搞得心神不宁的。他作比赛是最积极的，这次他联系好了其他两个强人组成一队，  

要在北大上面作比赛。也许受他影响吧，我和Andimeo也琢磨着再找个人一起做下比赛，  

由于我实在太菜，大牛人都不愿和我一起，还好without同学不嫌弃我们，  

就这样我们暂时先在一起做下题，Andimeo给我们取了个名字:SCUvbteam，  

就菜鸟的意思！由于我们水平有限，比赛结果当然很烂。 

不过发现几个人在一起做题还是比一个人强多了，

怎样在比赛的时候把3个人的水平都发挥出来？这个还需要好好锻炼团队合作呀！  
</code></pre>

<h2>热身赛受挫</h2>

<pre><code>2008-05-03  

今天做热身赛，一塌糊涂。只做了别人的一半，丢人丢到家了！不过也暴露了我的很多毛病，值得！

5个小时，只好好用了一半，后面就在想为什么D题会WA呢？实在想不出，去写F题，用暴力的方法，  

理论上这个题的复杂度该有10^8大！一秒肯定超时！怀着试一试的心里写了个，一交超时！果断的换方法，可是没写出来。

比赛结束后，到处找错误！先是D题，就一个BFS，可是为什么就WA呢！问了n个人，终于还是HXK同学帮我解决了，  

原来是我上数据结构课的时候睡觉，没认真听老师讲。在一个点进队列的时候就该把它标记，  

不应该等到出队列的时候再标记(这是何等弱智的问题呀）。这个是我的错，可是F题，我就有点不爽了！  

原来他们都是用暴力过的，数据非常的弱，可是我就TLE，想不通了！也试了好多次，发现我用了个库函数strlen（），  

他们没用! 改下，过了。我忍！数据也不应该卡这些地方啥！我们是学高效算法，而不是想方设法来扣这个时间哟！  

难道还不能用库函数？太扯淡了！以后我都不敢用库函数了！

这次比赛还有一个地方值得总结，就是自己的心态，太脆弱！被WA了几次，就心烦气躁！严重影响做后面的题！  
</code></pre>

<h2>四川大地震</h2>

<pre><code>2008-05-13  

这是我第一次经历地震，以前就只在新闻里看到过，没见识到地震的威力，  

这次是感受到了，而且很深刻！下午两点多钟，我们正在做ACM的组队赛，毫无征兆的，  

楼房摇了起来！越来越猛，我大脑里第一意识就是，这是什么?完全没有想到会是地震！  

只听旁边的without说了个“地震”，然后全机房的人都往外跑，我啥东西也没带起身往外跑，       

我当时真是半信半疑，"地震"可能吗？到走廊的时候，已经震得很厉害了，只见机房的门摇得啪啦啪啦的很响  

哇塞！来真的了，幸好我们在三楼，没一会就跑下来了，发现楼下全是人，到楼下的时候，还在震动！     

只觉得头晕，什么东西都在晃，最恐怖的是脚下站的大地直震！过一会就没震了，整个过程大概一分多钟左右！  
</code></pre>

<h2>大学疑惑</h2>

<pre><code>2008-06-19  

今天无聊，在网上到处逛了下，看了几篇博文，感慨呀！又看到现在大四的毕业就要离校了！  

想下自己，脑袋一片空白！不知我大四走的时候是什么样子。。。。到现在我都还没找到自己努力的方向，

ACM不可能是大学学习的全部，我也不可能把它当作全部！自己的专业知识几乎一片空白。。。

我现在看清了，当时高考我其实没有选错专业，没有去学经济。一个人的性格决定了他能干什么事，能干好什么事！

也许很多人认为性格可以改，但是对我来说，很难！以我的性格，注定该搞技术！

社交什么的我一点都不行，还常常为此郁闷。。。可是到现在，我没学到什么技术，基本的都没有。

又再想大学到底该怎么搞！！！现在一点都搞不懂，前大半学期迷迷糊糊，后小半学期准备考试。

每学期都这样，怎么继续下去呀。。。
</code></pre>

<h2>大三暑假</h2>

<pre><code>2009-08-02  

    放假快一个月了，在这个月里，我似乎什么也没做，完全的放松了一下！

看了两本网络小说，一本很长接近400万字吧，一本很短不到40万字。

很搞笑的是，长的那本被封了，不准写！说是里面有影响社会安定团结的因素！说的也对，  

在小说里面，把社会上的一些事情刻画的很真实，小说里面刻画的社会上的某些方面是很黑暗的，  

普通人看到的很多事情都是假的，里面到处都是权力和金钱的争斗！看了过后，心里就一直在想，

现实生活中是不是也是这样！反正搞得读者既觉得过瘾，又觉得心有不甘！  

短的那本就完全相反，写的都是些唯美的事情，让人感觉在现实生活中不可能遇到， 

但是每个人心里又向往，心里老想着要是我是主人公就好了。。。呵呵，这本当然没被封，听说很火，还出版了！  

哎，这些小说，当做消遣无聊时看下还可以，但千万不能当真，也不能常看，不然不成愤青，就成YY了！  

作者又不用负责，只需一句“故事纯属虚构”就over了！  

好了，小说也看了，游戏也玩了，该干正事了!
</code></pre>

<h2>大四找工作</h2>

<pre><code>    先说说找工作的感受吧，这次找工作的经历，给我没留下什么大的感触。被一些公司莫名其妙的鄙视了，  

也不知道问题出在哪儿！有的公司只要准备稍充分一点，感觉又恨容易。反正公司之间的考核标准五花八门，

你要是不了解这个公司看重的是哪方面，很快就会被pass掉！

暑假去个小公司兼职去了，基本没怎么准备找工作的事。然后9月份一个月基本呆在寝室看那本， 

我一直想看却没有看的电子书《UNIX网络编程》，一二卷加起来1500+页啊，这本书被奉为网络编程的经典，

当然不是那么容易就看懂啥，反正我就大概的翻了下，不懂的直接跳过，以后再来慢慢研究。之所以看这个书，

是因为很多公司的招聘上明确写着“熟悉网络编程，TCP/IP”，而这方面我之前基本上没什么了解，

看了这个书，至少感觉对付面试应该还是有点底的。

    9月份基本上就这么过了，在9月底的时候，来了迅雷招聘，因为一直没有复习基础知识，

而迅雷笔试的题目基本上都是C++基础，然后我就悲惨的连迅雷一笔都没过。。。随后就体验了第一次强笔，

也是我遇到最恼火的一次强笔(我一共应该强笔过3次)。由于对一笔失败的不甘心，在迅雷通知二笔的时候，

我也跑去了，一去发现不让强笔，有好几个从电子科大过来强笔的学生正在和工作人员交涉，说了好久，

大概笔试开始20分钟的时候，终于让我们笔了，随后我就跟悲剧了，我觉得这是我找工作中最悲剧的了。

笔试题目都是编程题，大概还是我没准备好，依然没有做好，但是最郁闷的是，在笔试途中，

打来一个010的电话，当时脑子里不知怎么想的，就直接挂了。。。我晕啊。后来才知道是百度打来的，

这样我就错过了百度给我的唯一的一次电话。

    国庆也在寝室宅满了，重新复习了下基础知识。10月中旬很多公司就来了，

先是百度、支付宝、阿里B2B、淘宝(我晕全是阿里集团的)、网易游戏、网宿科技、腾讯，

自己参加了几场笔试，但是直到20+号，俺才有面试，之前就觉得怎么进个面试都这么难啊！

随着我就经历了我大学最累的两三天，网易、腾讯、淘宝的面试给我安排在一天，我shit，

早上很早就起来，跑到一个四星级酒店去网易面试，在12点的时候终于面完了，

然后马不停蹄的跑去另一个四星级饭店腾讯面试，也等了好久，终于在3点钟的时候面完，

随着又跑到老校区淘宝面试(发现阿里的面试都比较节约，不像前两个，全是在四星级的地方)。

淘宝等的更久，连着面了两次，一直搞到晚上8点钟，到最后，我觉得我说话都成困难了，

那段自我介绍一天说了4次，说得我都想吐。。。接着第二天，淘宝三面，腾讯二面，

还好这些面试的时间都还没有冲突，随后的几天都是在围绕这三个公司转。

这几个公司招聘完了，10月份也完了，然后我的找工作阶段也差不多结束了
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[POJ 2796 单调栈]]></title>
    <link href="http://blog.youngxiao.com/blog/2016/03/15/my-third-blog/"/>
    <updated>2016-03-15T12:22:24+08:00</updated>
    <id>http://blog.youngxiao.com/blog/2016/03/15/my-third-blog</id>
    <content type="html"><![CDATA[<p>题目：给你一个序列，求其中一个子序列使得这个子序列和乘以这个子序列中最小值后最大（注，序列的值>=0)</p>

<p><strong>分析：</strong></p>

<p>（序列和 * 序列最小值）最大；对于一个元素，假设它是一个序列的最小值，则这个序列越长，最后的乘积就越大。</p>

<p>所以对于题目，我们只要对于<strong>每个元素，计算出“以这个元素作为序列最小值时，得到的最大乘积”</strong>，然后比较，取出最大值即可。</p>

<p>那问题的关键就在于，怎么得到 <strong>“以该元素作为序列最小值时的最长序列”，即从该元素开始像两边延伸到最大限度</strong></p>

<!-- more -->


<p>这个问题的特性就可以用单调栈来解决：</p>

<p><strong>单调栈:顾名思义就是在入栈时遵循单调原则，可以求出一个元素向左所能扩展到的最大长度，并不是说在这一段区间内是单调的，而是保证在该区间内该元素一定是最大或最小。</strong></p>

<p>我们有如下的性质：</p>

<ol>
<li>如果当前元素大于前一元素，那么前一元素能扩展到当前元素，同时说明前面的数对当前元素来说是没有贡献的</li>
<li>如果当前元素小于等于前一个元素，那么前面至少有一个元素不能扩展到当前元素的位置，那么这些不能继续扩展的元素的存在显的没有什么意义了，不妨删除它。</li>
</ol>


<p>我们得到两条结论：</p>

<p>1.一旦一个元素已经进入栈中那么这个元素向左扩展的位置就确定下来了.</p>

<p>2.一旦一个元素出栈被弹出栈,那么这个元素向右扩展的位置也确定下来了.</p>

<p>附本题代码：</p>

<pre><code>#include&lt;iostream 
#include&lt;stack&gt;
#include&lt;stdio.h&gt;
using namespace std;
#define maxx 110000
__int64 str[maxx],t[maxx];
struct node
{
    __int64 num,pre,next;//num记录数值，pre记录向前延伸多少个，next记录向后延伸多少个,k记录本身所处的位置
    __int64 k;
};
int main()
{
    int n;
    while(scanf("%d",&amp;n)&gt;0)
    {
        stack&lt;node&gt;Q;
        node tmp;
        __int64 ans=-100,sum=-100,num;
        str[0]=0;
        for(__int64 i=1;i&lt;=n;i++)
        {
            scanf("%I64d",&amp;t[i]);
            if(i==1)
                str[i]=t[i];
            else
                str[i]=str[i-1]+t[i];
        }
        tmp.num=t[1];
        tmp.pre=1;
        tmp.next=1;
        tmp.k=1;
        Q.push(tmp);
        __int64 x=0,y=0;
        for(__int64 i=2;i&lt;=n;i++)
        {
            node tmp1;
            tmp1.num=t[i];
            tmp1.pre=tmp1.next=1;
            tmp1.k=i;
            while(!Q.empty()&amp;&amp;tmp1.num&lt;=Q.top().num)
            {
                tmp=Q.top();
                Q.pop();
                if(!Q.empty())
                    Q.top().next+=tmp.next;
                tmp1.pre+=tmp.pre;
                ans=tmp.num*(str[tmp.k+tmp.next-1]-str[tmp.k-tmp.pre]);
                if(ans&gt;=sum)
                {
                    sum=ans;
                    x=tmp.k-tmp.pre+1;
                    y=tmp.k+tmp.next-1;
                }
            }
            Q.push(tmp1);
        }

        while(!Q.empty())
        {
            tmp=Q.top();
            Q.pop();
            if(!Q.empty())
                Q.top().next+=tmp.next;
            ans=tmp.num*(str[tmp.k+tmp.next-1]-str[tmp.k-tmp.pre]);
            if(ans&gt;=sum)
            {
                sum=ans;
                x=tmp.k-tmp.pre+1;
                y=tmp.k+tmp.next-1;
            }
        }

        if(n==0)x=y=0;
        printf("%I64d\n%I64d %I64d\n",sum,x,y);
    }
    return 0;
}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress+GitHub 搭建个人博客]]></title>
    <link href="http://blog.youngxiao.com/blog/2016/03/15/my-second-blog/"/>
    <updated>2016-03-15T10:56:57+08:00</updated>
    <id>http://blog.youngxiao.com/blog/2016/03/15/my-second-blog</id>
    <content type="html"><![CDATA[<p><strong>1. Octopress是博客工具，一套用来生成blog的系统。</strong></p>

<p><strong>2. GitHub是用来托管blog网页的网站</strong></p>

<!-- more -->


<h1>安装依赖工具</h1>

<p><strong>Git：</strong></p>

<blockquote><p><a href="http://msysgit.googlecode.com/files/Git-1.8.1.2-preview20130201.exe">http://msysgit.googlecode.com/files/Git-1.8.1.2-preview20130201.exe</a></p></blockquote>

<p><strong>Ruby：</strong></p>

<blockquote><p><a href="http://files.rubyforge.vm.bytemark.co.uk/rubyinstaller/rubyinstaller-1.9.3-p429.exe">http://files.rubyforge.vm.bytemark.co.uk/rubyinstaller/rubyinstaller-1.9.3-p429.exe</a></p></blockquote>

<p><strong>DevKit：</strong></p>

<blockquote><p><a href="http://cloud.github.com/downloads/oneclick/rubyinstaller/DevKit-tdm-32-4.5.2-20111229-1559-sfx.exe">http://cloud.github.com/downloads/oneclick/rubyinstaller/DevKit-tdm-32-4.5.2-20111229-1559-sfx.exe</a></p></blockquote>

<p><strong>Python：</strong></p>

<blockquote><p> <a href="http://www.python.org/ftp/python/2.7.5/python-2.7.5.msi">http://www.python.org/ftp/python/2.7.5/python-2.7.5.msi</a></p></blockquote>

<ul>
<li><p>安装Git：
Windows下安装Git很简单，一路next就可以了。</p></li>
<li><p>安装Ruby：
Ruby的安装也是一路next就可以，不过记得勾选“Add Ruby executables to your PATH”，<strong>将Ruby的执行路径加入到环境变量中</strong>，如果忘记勾选，也可以手动设置。安装完后可以在命令提示符中输入ruby –version 来确认是否安装成功。</p></li>
<li><p>安装DevKit：
DevKit下载下来的是一个自压缩文件，我们将其解压到D:/DevKit，有两点需要注意：</p>

<ol>
<li>解压目录中没有有中文和空格；</li>
<li>必须先安装Ruby，而且Ruby需要是RubyInstallser包安装。</li>
</ol>


<p>  解压DevKit后，在命令行输入以下命令来进行安装：</p>

<pre><code>  d:   
  cd DevKit  
  ruby dk.rb init   
  ruby dk.rb install  
</code></pre></li>
<li><p>安装Python：
安装Python,也是一路next就可以</p></li>
</ul>


<h1>配置octopress</h1>

<ul>
<li><p>通过Git Shell 进入bash界面，把octopress代码拉到本地<br/>
  <code>git clone git://github.com/imathis/octopress.git octopress</code></p></li>
<li><p>然后安装Octopress的依赖项，安装依赖项需要用到Ruby的gem，使用下面的命令可以更换gem的更新源，使用国内的淘宝镜像速度相对快点。</p>

<blockquote><pre><code>gem sources -a https://ruby.taobao.org/  
gem sources -r http://rubygems.org/  
gem sources -l  
</code></pre></blockquote></li>
<li><p>修改Octopress目录下的Gemfile文件，将第一行的<a href="http://rubygems.org/">http://rubygems.org/</a> 修改为<a href="http://ruby.taobao.org/">http://ruby.taobao.org/</a></p></li>
<li><p>在git bash界面进入到Octopress目录，输入下面命令进行依赖项的安装</p></li>
</ul>


<blockquote><p>  gem install bundler<br/>
  bundle install<br/>
  rake install</p></blockquote>

<p><strong>到此 octopress就已经配置OK！</strong></p>

<h1>将Octopress发布到Github #</h1>

<ul>
<li><p>首先在自己的github下新建一个<code>https://github.com/username/username.github.io</code>的repository. <strong>注意username替换为自己的github帐号名</strong></p></li>
<li><p>进入octopress目录，执行：<br/>
  <code>rake setup_github_pages</code><br/>
  这个命令的功能是 octopress的自带的功能，其实就是执行octopress/Rakefile里的命令。<br/>
  执行后，会要求你输入上一条的repository的地址。</p>

<p>  这个命令背后会做这几个事情：</p>

<pre><code>  1. 把git://github.com/imathis/octopress.git这个远程库的别名从origin改为octopress  
  2. 把https://github.com/username/username.github.io这个远程库作为默认的origin远程库  
  3. 把本地octopress目录切换到source分支  
  4. 新建octopress/_deploy目录，也设置为另一个git库且是master分支，对应的远程库也是https://github.com/username/username.github.io 
</code></pre></li>
<li><p>接着执行<code>rake generate</code>，会先清空public目录，根据source目录的内容，真正生成blog的页面文件, 存放到public目录下,所有我们需要添加的东西需要在source中添加。</p></li>
<li><p>再执行<code>rake deploy</code>，它的作用是: <br/>
  <strong>命令首先清空_deploy目录，然后将public目录整个拷贝过来</strong>，然后commit到github，并且把他们push到对应的远程库里去，如果发现push失败，则需要我们手动到deploy去把git对应关系建立好 <code>“git branch --set-upstream master origin/master”</code>,<br/>
  再执行rake deploy,就成功了~<br/>
  到这里，blog所需要的网页文件已经上传到了github对应库的<strong>master分支</strong>。</p></li>
<li><p>最后我们需要把octopress工程目录，也就是我们生成blog的源目录文件，提交上传</p>

<pre><code>  git add .  
  git commit -m 'your message'
  git push origin source  
</code></pre>

<p>  需要注意的是，<strong>这之前我们在github上是没有source分支的</strong>，执行“git push origin source”时，git发现远程库没有对应的分支，就会自动创建。</p></li>
</ul>


<h1>最后总结下 ：</h1>

<ul>
<li><p>1、我们的工程目录是octopress，它是source分支，对应github上的也是source分支，它里面的内容是生成blog的代码源文件。</p></li>
<li><p>2、octopress/_deploy目录是blog网站文件的目录，访问网站需要的文件都在这个目录里，它对应github上的master分支，所以要想更新blog，内容必须提交到master分支才会有效。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress怎么添加文章]]></title>
    <link href="http://blog.youngxiao.com/blog/2016/03/15/my-four-blog/"/>
    <updated>2016-03-15T10:56:57+08:00</updated>
    <id>http://blog.youngxiao.com/blog/2016/03/15/my-four-blog</id>
    <content type="html"><![CDATA[<h1>添加文章</h1>

<ol>
<li><p><code>rake new_post['my first octopress blog']</code> 这样可以生成一片文章的源文件。<br/>
注意，rake new_post[&lsquo;my first octopress blog&rsquo;]中的my first octopress blog 并不是博客标题，而是和生成的文件名以及url地址有关，该名称不支持中文。博客标题可以在生成的markdown文件中修改。生成的markdown文件在octopress/source/_posts目录中。</p>

<p>  可以用<em>markdownpad</em>直接编译这个文件，来写blog内容。</p></li>
</ol>


<!-- more -->


<ol>
<li><p>每次写完blog后，需要执行rake generate，这时生成真正的网页文件。</p></li>
<li><p>然后再执行命令rake deploy 就可以将本地的内容发布到Github上。</p></li>
<li><p>最后保存文章的code文件，提交到source目录下</p>

<p>git add .<br/>
git commit -m “your message”<br/>
git push origin source</p></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git基础知识]]></title>
    <link href="http://blog.youngxiao.com/blog/2016/03/15/my-first-blog/"/>
    <updated>2016-03-15T10:32:49+08:00</updated>
    <id>http://blog.youngxiao.com/blog/2016/03/15/my-first-blog</id>
    <content type="html"><![CDATA[<h1>Git原理</h1>

<ol>
<li>Git是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。重点在于<strong>分布式</strong>，每个人的电脑上都是一个完整的版本库，所以<strong>使用Git Commit的时候，不是提交到服务器，而是提交到本地的版本库</strong>。</li>
</ol>


<!-- more -->


<ol>
<li><p>工作区有一个隐藏目录.git，这就是Git在本机的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。</p></li>
<li><p>我们把文件往Git版本库里添加的时候，是分两步执行的：</p>

<p> 第一步是用<strong>git add把文件添加进去，实际上就是把文件修改添加到暂存区</strong>；</p>

<p> 第二步是用<strong>git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。（注意这只是提交到本地库的分支）</strong></p></li>
<li><p>远程仓库，指保存在服务器上的仓库，这里主要指github上托管的仓库。
<strong>这里有需要注意的地方：</strong></p>

<pre><code> A、github上建立仓库后，它也有分支的概念，本地仓库也有分支的概念，比如“https://github.com/KeepMemoryAlive/KeepMemoryAlive.github.io”这个仓库，其实它在github上可能有几个分支。

 B、本地仓库和远程库之间 必须要有tracking information，才能push 和 pull, 当我们用git clone时， 默认是建立的**本地master分支** 与 **远程master分支**之间的联系。
</code></pre></li>
</ol>


<h1>Git常用命令</h1>

<ul>
<li><p>git clone:如果不指定本地目录名，就同名，注意默认切出来的是master分支<br/>
<code>git clone: &lt;版本库的网址&gt; &lt;本地目录名&gt;</code></p></li>
<li><p>git remote: Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名.<br/>
  <code>git remote -v</code></p>

<p>   octopress       git://github.com/imathis/octopress.git (fetch)<br/>
   octopress       git://github.com/imathis/octopress.git (push)<br/>
  origin  <a href="https://github.com/KeepMemoryAlive/KeepMemoryAlive.github.io">https://github.com/KeepMemoryAlive/KeepMemoryAlive.github.io</a> (fetch)
  origin  <a href="https://github.com/KeepMemoryAlive/KeepMemoryAlive.github.io">https://github.com/KeepMemoryAlive/KeepMemoryAlive.github.io</a> (push)</p>

<p>  克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定。<br/>
  <code>git clone -o jQuery https://github.com/jquery/jquery.git</code></p>

<p>  <code>git remote show &lt;主机名&gt;</code>: 查看该主机的详细信息<br/>
  <code>git remote add &lt;主机名&gt; &lt;网址&gt;</code> : 命令用于添加远程主机。<br/>
  <code>git remote rename &lt;原主机名&gt; &lt;新主机名&gt;</code></p>

<p>  <strong>注意：</strong>  remote只代表对应的远程主机，并没有列出本地分支和远程分支之间的tracking information</p></li>
<li><p>git pull: 取回远程主机<strong>某个分支</strong>的更新，再与<strong>本地的指定分支合并</strong>。它的完整格式稍稍有点复杂。 <br/>
  <code>git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</code></p>

<p>  在某些场合，Git会自动在本地分支与远程分支之间，建立一种<strong>追踪关系</strong>(tracking)。比如，<strong>在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系</strong>，也就是说，本地的master分支自动”追踪”origin/master分支。</p>

<p>  Git也允许手动建立追踪关系：<br/>
  <code>git branch --set-upstream master origin/next</code></p>

<p>  上面命令指定<strong>本地master</strong>分支追踪origin/next分支，如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。<br/>
  <code>git pull origin</code></p>

<p>  如果当前分支只有一个追踪分支，连远程主机名都可以省略。<br/>
  <code>git pull</code><br/>
  <strong>注意：用git pull时 一定要注意，本地分支与远程分支的对应关系，避免提错了</strong></p></li>
<li><p>git push:用于将本地分支的更新，推送到远程主机， 就是把本地库和远程库同步，相当于svn的提交。<br/>
<code>git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</code></p>

<p>  <strong>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支(通常两者同名)，如果该远程分支不存在，则会被新建。</strong><br/>
  <code>git push origin master</code><br/>
上面命令表示，将<strong>本地的master</strong>分支推送到origin主机的master分支。如果后者不存在，则会被新建。</p>

<p>  如果当前分支只有一个追踪分支，那么主机名都可以省略。<br/>
  <code>git push</code>  <strong>用这个命令一定要注意 当前的对应关系</strong></p></li>
<li><p>git status:查看当前工作区的修改</p></li>
<li><p>git log: 如果不带任何参数，它会列出所有历史记录，最近的排在最上方<br/>
  <code>git log -n</code> : 选择显示前N条。<br/>
  <code>git log --pretty=oneline</code> : 一行显示，只显示哈希值和提交说明。</p></li>
<li><p>git reflog: 列出了head曾经指向过的一系列commit.</p></li>
<li><p>git reset：回退版本<br/>
  <code>git reset --hard 66a4b03</code> 回退到66a4b03指定的版本，这个指通过 git reflog可以查看</p></li>
</ul>

]]></content>
  </entry>
  
</feed>
